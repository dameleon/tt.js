<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">;(function(global, document, undefined) {
    &quot;use strict&quot;;

    var IDENT = &quot;tt&quot;,
        querySelectorRe = /^(.+[\#\.\s\[\*&gt;:,]|[\[:])/,
        loaded = false,
        loadQueue = [],
        env = tt_createEnvData(global.navigator),
        domTester = document.createElement(&quot;div&quot;);

    // call load callback queue
    document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
        loaded = true;
        for (var i = 0, iz = loadQueue.length; i &lt; iz; ++i) {
            loadQueue[i]();
        }
    }, false);

    // for old android compatiblity
    // Object.keys shim - MDN https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys#Compatiblity
    if (!Object.keys) {
        Object.keys=(function(){var a=Object.prototype.hasOwnProperty,b=!{toString:null}.propertyIsEnumerable(&quot;toString&quot;),c=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=c.length;return function(e){if(&quot;object&quot;!==typeof e&amp;&amp;&quot;function&quot;!==typeof e||null===e){throw new TypeError(&quot;Object.keys called on non-object&quot;);}var f=[];for(var g in e){if(a.call(e,g)){f.push(g);}}if(b){for(var h=0;d&gt;h;h++){if(a.call(e,c[h])){f.push(c[h]);}}}return f;};})();
    }
    // Array.isArray shim
    if (!Array.isArray) {
        Array.isArray=function(a){return Object.prototype.toString.call(a)===&quot;[object Array]&quot;;};
    }
    // String.prototype.trim = MDN https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/String/trim#Compatibility
    if (!String.prototype.trim) {
        String.prototype.trim=function(){return this.replace(/^\s+|\s+$/g,&quot;&quot;);};
    }
    // Node.contains shim
    if (!Node.contains) {
        Node.contains=function(a){var b=this.compareDocumentPosition(a);return (b===0||b&amp;Node.DOCUMENT_POSITION_CONTAINED_BY);};
    }

<span id='tt'>    /**
</span>     * tt.js main function
     *
     * This function does the following arguments to be passed by
     *
     * **CSSQueryString, HTMLElement, NodeList or its like Array, document or document.body, tt object**
     *
     * Create tt class object (DOM Operator)
     *
     * **Function**
     *
     * If the HTML is already loaded is executed immediately, if not already loaded is executed at the timing of the DOMContentLoaded
     *
     * @class tt
     * @param {String|Function|HTMLElement|NodeList|NodeList like Array|document|document.body} any
     * @param {HTMLElement} [options] parent If first params is String, sets the parent of the search target
     * @return {Object|undefined} Return tt object of if first params is Function return undefined
     */
    function tt(any, parent) {
        var target = null,
            selector = &quot;&quot;;

        if (typeof any === &quot;string&quot;) {
            selector = any;
            parent = parent || document;
            target = querySelectorRe.test(any) ?
                        parent.querySelectorAll(any) :
                     any[0] === &quot;#&quot; ?
                        [parent.getElementById(any.substring(1, any.length))] :
                     any[0] === &quot;.&quot; ?
                        parent.getElementsByClassName(any.substring(1, any.length)) :
                        parent.getElementsByTagName(any);
        } else if (any) {
            if (any.nodeType === 1) {
                target = [any];
            } else if (tt_isNodeList(any) ||
                      (Array.isArray(any) &amp;&amp; any.length &amp;&amp; any[0].nodeType)) {
                target = any;
            } else if (any === document || any === document.body) {
                target = [document.body];
            } else if (typeof any === &quot;function&quot;) {
                if (loaded) {
                    any();
                } else {
                    loadQueue.push(any);
                }
                return;
            } else if (any instanceof TTWorker) {
                return any;
            }
        }
        return new TTWorker(target || [], selector);
    }

    //// static methods
    tt.ajax          = tt_ajax;
    tt.createEnvData = tt_createEnvData;
    tt.camelizer     = tt_camelizer;
    tt.hyphenizer    = tt_hyphenizer;
    tt.cssPrefix     = tt_cssPrefix;
    tt.each          = tt_each;
    tt.extend        = tt_extend;
    tt.env           = env;
    tt.isArray       = Array.isArray;
    tt.isNodeList    = tt_isNodeList;
    tt.match         = tt_match;
    tt.param         = tt_param;
    tt.parseJSON     = tt_parseJSON;
    tt.proxy         = tt_proxy;
    tt.query2object  = tt_query2object;
    tt.tag           = tt_tag;
    tt.triggerEvent  = tt_triggerEvent;
    tt.type          = tt_type;

    //// Iterate functions
<span id='tt-static-method-each'>    /**
</span>     * Execute iterate a function from array or object
     *
     * @method each
     * @static
     * @param {Array|Object} any target to pass to a function
     * @param {Function} fn function to execute iteratively
     */
    function tt_each(any, fn) {
        var arr, key,
            i = 0, iz;

        if (Array.isArray(any)) {
            iz = any.length;
            for (; i &lt; iz; ++i) {
                fn(any[i], i);
            }
        } else if (typeof any === &quot;object&quot;) {
            arr = Object.keys(any);
            iz = arr.length;
            for (; i &lt; iz; ++i) {
                key = arr[i];
                fn(key, any[key]);
            }
        }
    }

<span id='tt-static-method-extend'>    /**
</span>     * Extend target object with each objects
     * If first argument is true, will be recursive copy
     *
     * @method extend
     * @static
     * @param {Object|Boolean} any first target object or deep flag
     * @param {Object} [options] override objects
     * @return {Object} result object
     */
    function tt_extend() {
        var args = [].slice.call(arguments),
            i = 1, iz = args.length,
            deep = false,
            arg, target;

        if (args[0] === true) {
            deep = true;
            ++i;
        }
        target = args[(i - 1)] || {};

        for (; i &lt; iz; ++i) {
            arg = args[i];
            if (tt_type(arg) !== &quot;object&quot;) {
                continue;
            }
            tt_each(Object.keys(arg), _extend);
        }
        return target;

        function _extend(key, index) {
            if (deep &amp;&amp;
                tt_type(target[key], &quot;object&quot;) &amp;&amp;
                tt_type(arg[key], &quot;object&quot;)) {
                    tt_extend(target[key], arg[key]);
            } else {
                target[key] = arg[key];
            }
        }
    }

<span id='tt-static-method-match'>    /**
</span>     * Execute iterate a function from array or object
     *
     * @method match
     * @static
     * @param {Array|Object} any target to pass to a function
     * @param {Function} fn function to execute iteratively
     */
    function tt_match(any, fn) {
        var arr,
            key, res = {},
            i = 0, iz;

        if (Array.isArray(any)) {
            iz = any.length;
            for (; i &lt; iz; ++i) {
                if (fn(any[i], i)) {
                    return any[i];
                }
            }
        } else if (typeof any === &quot;object&quot;) {
            arr = Object.keys(any);
            iz = arr.length;
            for (; i &lt; iz; ++i) {
                key = arr[i];
                if (fn(key, any[key], i)) {
                    res[key] = any[key];
                    return res;
                }
            }
        }
        return null;
    }


    //// detect type functions
<span id='tt-static-method-isNodeList'>    /**
</span>     * Detect array strictly
     *
     * @method isNodeList
     * @static
     * @param {Any} target detect target
     * @return {Boolean} result
     */
    function tt_isNodeList(any) {
        var type=Object.prototype.toString.call(any);

        return type === &quot;[object NodeList]&quot; || type === &quot;[object HTMLCollection]&quot;;
    }

<span id='tt-static-method-type'>    /**
</span>     * Return target type
     * If matches is passed and returns result of comparing target
     *
     * @method type
     * @static
     * @param {Any} target judgment target
     * @param {String|Array} matches List, or string type to be compared
     * @return {Boolean} result
     */
    function tt_type(target, matches) {
        var res = target === null       ? &quot;null&quot; :
                  target === void 0     ? &quot;undefined&quot; :
                  target === global     ? &quot;global&quot; :
                  target === document   ? &quot;document&quot; :
                  target.nodeType       ? &quot;node&quot; :
                  Array.isArray(target) ? &quot;array&quot; :
                  tt_isNodeList(target) ? &quot;nodelist&quot; : undefined;

        if (!res) {
            res = typeof target;
            if (res === &quot;object&quot;) {
                res = Object.prototype.toString.call(target).toLowerCase().match(/.*\s([a-z]*)\]/)[1];
            }
        }
        if (!matches) {
            return res;
        } else if (Array.isArray(matches)) {
            for (var i = 0, iz = matches.length; i &lt; iz; ++i) {
                if (matches[i] === res) {
                    return true;
                }
            }
            return false;
        } else {
            return matches === res;
        }
    }


    //// useful functions
<span id='tt-static-method-ajax'>    /**
</span>     * XMLHttpRequest wrapper method
     *
     * @method ajax
     * @static
     * @param {String|Object} any request url or setting object
     * @param {Object} [options] setting setting object
     * @return {Object} XMLHttpRequest object
     */
    function tt_ajax(any, setting) {
        var called = false,
            xhr = new XMLHttpRequest();

        setting = setting || {};
        if (tt_type(any, &quot;object&quot;)) {
            setting = any;
        } else if (tt_type(any, &quot;string&quot;)) {
            setting.url = any;
        } else {
            throw new Error(&quot;Error: missing argument&quot;);
        }

        setting = tt_extend({
            async       : true,
            beforeSend  : null,
            cache       : true,
            complete    : null,
            contentType : &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,
            context     : document.body,
            data        : null,
            dataType    : &quot;text&quot;,
            error       : null,
            headers     : null,
            mimeType    : null,
            success     : null,
            timeout     : 0,
            type        : &quot;GET&quot;,
            url         : &quot;&quot;,
            user        : &quot;&quot;,
            password    : &quot;&quot;
        }, setting);

        setting.type = setting.type.toUpperCase();

        if (setting.data &amp;&amp; setting.type === &quot;GET&quot;) {
            setting.url =
                setting.url +
                setting.url.indexOf(&quot;?&quot;) &gt; -1 ? &quot;&amp;&quot; : &quot;?&quot; +
                tt_param(setting.data);
            setting.data = null;
        } else {
            setting.data = tt_param(setting.data);
        }

        xhr.onerror = function() {
            _callCallbacks(0);
        };

        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
                _callCallbacks(xhr.status);
            }
        };

        xhr.open(setting.type,
                 setting.url,
                 setting.async,
                 setting.user,
                 setting.password);

        if (setting.type === &quot;POST&quot;) {
            xhr.setRequestHeader(&quot;Content-type&quot;, setting.contentType);
            xhr.setRequestHeader(&quot;Content-length&quot;, setting.data.length);
        }
        if (tt_type(setting.headers, &quot;object&quot;)) {
            tt_each(setting.headers, function(key, value) {
                xhr.setRequestHeader(key, value);
            });
        }
        if (setting.dataType) {
            try {
                xhr.responseType = setting.dataType;
            } catch (e) {
                xhr.responseType = &quot;text&quot;;
            }
        }
        if (setting.mimeType) {
            xhr.overrideMimeType(setting.mimeType) ;
        }
        if (setting.beforeSend) {
            setting.beforeSend(xhr);
        }
        if (setting.timeout) {
            xhr.timeout = setting.timeout;
        }
        xhr.send(setting.data);

        return xhr;

        function _callCallbacks(statusCode) {
            if (called) {
                return;
            }
            called = true;

            var res, context = setting.context;

            if (statusCode &gt;= 200 &amp;&amp; statusCode &lt; 400) {
                try {
                    res = xhr.response || xhr.responseText;
                } catch (e) {
                    res = xhr.responseText;
                }
                if (setting.dataType === &quot;json&quot; &amp;&amp; tt_type(res, &quot;string&quot;)) {
                    res = tt_parseJSON(res);
                }
                if (setting.success) {
                    setting.success.apply(context, [res, statusCode, xhr]);
                }
            } else {
                if (setting.error) {
                    setting.error.apply(context, [xhr, statusCode]);
                }
            }
            if (setting.complete) {
                setting.complete.apply(context, [xhr, statusCode]);
            }
            xhr = null;
        }
    }

<span id='tt-static-method-createEnvData'>    /**
</span>     * Create an object of environmental information based on the information of the navigator
     *
     * Environmental information can be obtained based on the following key
     *
     * Decision os:         ios, android, windowsPhone
     *
     * Decision browsers:   mobileSafari, androidBrowser, chrome, firefox, opera, ie, other
     *
     * version information: (only mobileSafari androidBrowser)
     *
     *                      version(raw data)
     *
     *                      versionCode(version number of 4-digit or higher)
     *
     * @method createEnvData
     * @static
     * @param {Object} navigator global.navigator object
     * @return {Object} object
     */
    function tt_createEnvData(nav) {
        var res = {},
            ua = (nav || global.navigator).userAgent.toLowerCase();

        res.android = /android/.test(ua);
        res.ios = /ip(hone|od|ad)/.test(ua);

        if (!res.android &amp;&amp; !res.ios) {
            res.windowsPhone = /windows\sphone/.test(ua);
            res.ie = /msie/.test(ua);
        }

        res.chrome = /(chrome|crios)/.test(ua);
        res.firefox = /firefox/.test(ua);
        res.opera = /opera/.test(ua);
        res.androidBrowser = !res.chrome &amp;&amp; res.android &amp;&amp; /applewebkit/.test(ua);
        res.mobileSafari = !res.chrome &amp;&amp; res.ios &amp;&amp; /applewebkit/.test(ua);

        res.version =
            (res.androidBrowser || res.android &amp;&amp; res.chrome) ? ua.match(/android\s(\S.*?)\;/) :
            (res.mobileSafari || res.ios &amp;&amp; res.chrome) ? ua.match(/os\s(\S.*?)\s/) :
            null;
        res.version = res.version ?
            res.ios ?
                res.version[1].replace(&quot;_&quot;, &quot;.&quot;) :
                res.version[1] :
            null;
        res.versionCode = _getVersionCode(res.version);
        res.supportTouch = &quot;ontouchstart&quot; in global;

        return res;

        function _getVersionCode(version) {
            if (!version) {
                return null;
            }
            var res, digit = 4, diff = 0;

            version = version.replace(/\D/g, &quot;&quot;);
            diff = digit - version.length;

            if (diff &gt; 0) {
                res = (+version) * Math.pow(10, diff);
            } else {
                res = +version;
            }
            return res;
        }
    }

<span id='tt-static-method-camelizer'>    /**
</span>     * Get string CSS camel case from string of CSS hyphen case
     *
     * @method camelizer
     * @static
     * @param {String} str CSS property value
     * @return {String}
     */
    function tt_camelizer(str) {
        if (!str || typeof str !== &quot;string&quot;) {
            throw new Error(&quot;Argument error&quot;);
        }
        var res = &quot;&quot;;

        if (str[0] === &quot;-&quot;) {
            str = str.substr(1, str.length);
        }
        tt.each(str.split(&quot;-&quot;), function(value, index) {
            if (!index) {
                res += value;
                return;
            }
            res += value[0].toUpperCase() + value.substr(1, value.length);
        });
        return res || str;
    }

<span id='tt-static-method-cssPrefix'>    /**
</span>     * Get value of CSS with a prefix
     *
     * @method cssPrefix
     * @static
     * @param {String} value CSS value
     * @param {Array} prefix additional prefixes list
     * @return {Array}
     */
    function tt_cssPrefix(value, prefix) {
        var res = [];

        prefix = prefix || [&quot;webkit&quot;, &quot;moz&quot;, &quot;o&quot;, &quot;ms&quot;, &quot;khtml&quot;];
        tt_each(prefix, function(str, index) {
            res[index] = &quot;-&quot; + str + &quot;-&quot; + value;
        });
        return res;
    }

<span id='tt-static-method-hyphenizer'>    /**
</span>     * Get string CSS hyphen case from string of CSS camel case
     *
     * @method hyphenizer
     * @static
     * @param {String} str CSS property value
     * @return {String}
     */
    function tt_hyphenizer(str) {
        if (!str || typeof str !== &quot;string&quot;) {
            throw new Error(&quot;Argument error&quot;);
        }
        var prefix = [&quot;webkit&quot;, &quot;moz&quot;, &quot;o&quot;, &quot;ms&quot;, &quot;khtml&quot;],
            upperRe = /[A-Z]/g,
            upperStr = str.match(upperRe),
            res = &quot;&quot;;

        tt_each(str.split(upperRe), function(value, index) {
            if (prefix.indexOf(value) &gt; -1) {
                res += &quot;-&quot; + value;
                return;
            } else if (!index) {
                res += value;
                return;
            }
            res += (&quot;-&quot; + upperStr.shift().toLowerCase() + value);
        });
        return res || str;
    }

<span id='tt-static-method-param'>    /**
</span>     * Parse query string to object
     *
     * @method param
     * @static
     * @param {String} query query string
     * @return {Object} result
     */
    function tt_param(obj) {
        if (!tt_type(obj, &quot;object&quot;)) {
            return obj;
        }
        var key, keys = Object.keys(obj),
            i = 0, iz = keys.length,
            results = [];

        for (;i &lt; iz; ++i) {
            key = keys[i];
            results.push(encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(obj[key]));
        }
        return results.join(&quot;&amp;&quot;);
    }

<span id='tt-static-method-parseJSON'>    /**
</span>     * Parse string of json to json object
     *
     * @method parseJSON
     * @static
     * @param {String} text parse target string
     * @return {Function} Callback function
     */
    function tt_parseJSON(text) {
        if (!text) {
            return {};
        } else if (typeof text === &quot;object&quot;) {
            return text;
        }
        // idea from twitter@uupaa
        var obj;

        try {
            obj = JSON.parse(text);
            return obj;
        } catch (p_o) {}
        try {
            /*jshint evil: true */
            obj = (new Function(&#39;return &#39; + text))();
        } catch (o_q) {
            throw new Error(&quot;Can&#39;t parse text to json&quot;);
        }
        return obj;
    }

<span id='tt-static-method-proxy'>    /**
</span>     * Returns a function and arguments hold any context
     *
     * @method proxy
     * @static
     * @param {Function} func
     * @param {Any} context
     * @param {Any} [options] args
     * @return {Function} Callback function
     */
    function tt_proxy() {
        if (arguments.length &lt; 2) {
            throw new Error(&quot;Missing argument error&quot;);
        }
        var args = [].slice.call(arguments),
            func = args.shift(),
            context = args.shift(),
            tmp;

        if (typeof context === &quot;string&quot;) {
            tmp = func[context];
            context = func;
            func = tmp;
        }
        return function() {
            return func.apply(context, args);
        };
    }

<span id='tt-static-method-query2object'>    /**
</span>     * Parse query string to object
     *
     * @method query2object
     * @static
     * @param {String} query query string
     * @return {Object} result
     */
    function tt_query2object(query) {
        if (!tt_type(query, &quot;string&quot;)) {
            return {};
        }
        if (query[0] === &quot;?&quot;) {
            query = query.substr(1, query.length);
        }
        var result = {},
            pair = query.split(&quot;&amp;&quot;),
            i = 0, iz = pair.length;

        for (; i &lt; iz; ++i) {
            var k_v = pair[i].split(&quot;=&quot;);

            result[k_v[0]] = k_v[1];
        }
        return result;
    }

<span id='tt-static-method-tag'>    /**
</span>     * Create HTMLElement or tt object which involve it
     *
     * @method tag
     * @static
     * @param {String} name tag name
     * @param {Boolean} [createTT] If pass to true, return new tt object with element
     * @return {HTMLElement|Object} HTMLelement or tt object
     */
    function tt_tag(name, createTT) {
        if (!name || typeof name !== &quot;string&quot;) {
            throw new Error(&quot;Argument error&quot;);
        }
        var tag = document.createElement(name);

        return createTT ? tt(tag) : tag;
    }

<span id='tt-static-method-triggerEvent'>    /**
</span>     * Trigger event to target element
     *
     * @method triggerEvent
     * @static
     * @param {HTMLElement} node target HTMLElement
     * @param {String} event event type string
     * @param {String} name event name
     * @param {Boolean} [bubbles] bubbling flag
     * @param {Boolean} [cancelable] cancelable flag
     */
    function tt_triggerEvent(node, event, name, bubbles, cancelable) {
        if (!node || !event) {
            throw new Error(&quot;Missing argument error&quot;);
        }
        if (!tt_type(name, &quot;string&quot;)) {
            name = event;
            event = name === &quot;click&quot; ? &quot;MouseEvents&quot; : &quot;Event&quot;;
        }
        var ev = document.createEvent(event);

        ev.initEvent(name,
                     bubbles !== undefined ? bubbles : true,
                     cancelable !== undefined ? cancelable : true);
        node.dispatchEvent(ev);
    }


<span id='TTWorker-method-constructor'><span id='TTWorker'>    /**
</span></span>     * Create TTWorker object class
     *
     * @class TTWorker
     * @constructor
     * @param {Array|NodeList} nodes NodeList or Array incorporates elements
     * @param {String} selector selector text
     */
    function TTWorker(nodes, selector) {
        var i = 0, iz;

<span id='TTWorker-property-selector'>        /**
</span>         * Selector text
         *
         * @property selector
         * @type String
         */
        this.selector = selector;

<span id='TTWorker-property-length'>        /**
</span>         * Length of registered elements
         *
         * @property length
         * @type Number
         */
        this.length = iz = nodes.length;

<span id='TTWorker-property-_events'>        /**
</span>         * Event registration information of this tt object
         *
         * @property _events
         * @type Object
         * @private
         */
        this._events = {};

<span id='TTWorker-property-_delegates'>        /**
</span>         * Delegate registration information of this tt object
         *
         * @property _delegates
         * @type Object
         * @private
         */
        this._delegates = {};

<span id='TTWorker-property-_data'>        /**
</span>         * Data for this tt object
         *
         * @property _data
         * @type Object
         * @private
         */
        this._data = {};

        for (; iz; ++i, --iz) {
            this[i] = nodes[i];
        }
        return this;
    }

    tt.fn = TTWorker.prototype = {
        constructor: TTWorker,

<span id='TTWorker-method-get'>        /**
</span>         * Returns elements
         *
         * @method get
         * @param {Number} index elements index
         * @return {HTMLElement} one of registered HTMLElement
         */
        get: function(index) {
            return this[index || 0];
        },

<span id='TTWorker-method-toArray'>        /**
</span>         * Returns array in elements
         *
         * @method toArray
         * @return {Array} registered elements
         */
        toArray: function() {
            var arr = [];

            this.each(function(index) {
                arr[index] = this;
            });
            return arr;
        },

<span id='TTWorker-method-each'>        /**
</span>         * Call function with context of HTMLElement and parameter of elements index number
         *
         * @method each
         * @chainable
         * @param {Function} fn Function to be executed repeatedly
         * @return {Object} TTWorker object
         */
        each: function(fn) {
            var i = 0, iz = this.length;

            for (; iz; ++i, --iz) {
                fn.call(this[i], i);
            }
            return this;
        },

<span id='TTWorker-method-match'>        /**
</span>         * Call function with context of HTMLElement and parameter of elements index number
         * If it returns true, then this function return context that matches
         *
         * @method match
         * @param {Function} fn Function to be executed repeatedly
         * @return {Object} TTWorker Object
         */
        match: function(fn) {
            var i = 0, iz = this.length;

            for (; iz; ++i, --iz) {
                if (fn.call(this[i], i)) {
                    return this[i];
                }
            }
            return null;
        },

<span id='TTWorker-method-push'>        /**
</span>         * Push element(s) to TTWorker Object
         *
         * @method push
         * @chainable
         * @param {HTMLElement|NodeList|Array} any element or elements list
         * @return {Object} TTWorker Object
         */
        push: function(any) {
            if (any &amp;&amp; any.nodeType) {
                this[this.length] = any;
                ++this.length;
            } else if (tt_type(any, [&quot;array&quot;, &quot;nodelist&quot;])) {
                var i = 0, iz = any.length;

                for (; iz; ++i, --iz) {
                    this[this.length] = any[i];
                    ++this.length;
                }
            }
            return this;
        },

<span id='TTWorker-method-indexOf'>        /**
</span>         * Get index of registered element
         *
         * @method indexOf
         * @param {HTMLElement} node serach target element
         * @return {Number} index number
         */
        indexOf: function(node) {
            var res = -1;

            this.match(function(index) {
                if (this === node) {
                    res = index;
                    return true;
                }
                return false;
            });
            return res;
        },

<span id='TTWorker-method-on'>        /**
</span>         * Bind events to HTMLElement
         *
         * @method on
         * @chainable
         * @param {String} type
         * @param {String|Function} any
         * @param {Function} [options] callback
         * @return {Object} TTWorker Object
         */
        on: function(type, any, callback) {
            return tt_type(any, &quot;string&quot;) ?
                    this.delegate(type, any, callback) :
                    this.bind(type, any);
        },

<span id='TTWorker-method-off'>        /**
</span>         * Un bind events from HTMLElement
         *
         * @method off
         * @chainable
         * @param {String} type
         * @param {String|Function} any
         * @param {Function} callback
         * @return {Object} TTWorker Object
         */
        off: function(type, any, callback) {
            return tt_type(any, &quot;string&quot;) ?
                    this.undelegate(type, any, callback) :
                    this.unbind(type, any);
        },

<span id='TTWorker-method-bind'>        /**
</span>         * Bind events to HTMLElement
         * This is simply wrapper of addEventListener
         *
         * @method bind
         * @chainable
         * @param {String} type
         * @param {Function|Object} callback
         * @param {Boolean} [options] capture
         * @return {Object} TTWorker Object
         */
        bind: function(type, any, capture) {
            capture = capture || false;
            var self = this,
                event = this._events[type];

            if (!event) {
                event = this._events[type] = {};
                event.callbacks = [];
                event.handler = function(ev) {
                    var data = ev._tt_data,
                        args = Array.isArray(data) ?
                                [].concat(data) : [];

                    args.unshift(ev);
                    tt_each(event.callbacks, function(callback) {
                        if (typeof callback === &quot;function&quot;) {
                            callback.apply(ev.currentTarget, args);
                        } else if (callback &amp;&amp; callback.handleEvent) {
                            callback.handleEvent.apply(ev.currentTarget, args);
                        }
                    });
                };
                this.each(function() {
                    this.addEventListener(type, event.handler, capture);
                });
            }
            event.callbacks.push(any);
            return this;
        },

<span id='TTWorker-method-unbind'>        /**
</span>         * Un bind events from HTMLElement
         * This is simply wrapper of removeEventListener
         *
         * @method unbind
         * @chainable
         * @param {String} type
         * @param {Function|Object} any
         * @return {Object} TTWorker Object
         */
        unbind: function(type, any) {
            var event = this._events[type],
                index = event ?
                        event.callbacks.indexOf(any) : -1;

            if (!event || index &lt; 0) {
                return;
            }
            event.callbacks.splice(index, 1);
            if (!event.callbacks.length) {
                this.each(function() {
                    this.removeEventListener(type, event.handler);
                });
            }
            return this;
        },

<span id='TTWorker-method-delegate'>        /**
</span>         * Bind events to HTMLElement
         * To bind the event of delegate type
         *
         * @method delegate
         * @chainable
         * @param {String} type
         * @param {String|Object} target
         * @param {Function|Object} callback
         * @return {Object} TTWorker Object
         */
        delegate: function(type, target, callback) {
            var delegate = this._delegates[type],
                listener = {
                    target: target,
                    callback: callback
                };

            if (!delegate) {
                delegate = this._delegates[type] = {};
                delegate.listeners = [];
                delegate.handler = function(ev) {
                    var event,
                        eventTarget = ev.target,
                        args = arguments;

                    tt_match(delegate.listeners, function(listener) {
                        var match = tt(listener.target).match(function() {
                            if (this.contains(eventTarget)) {
                                return true;
                            }
                            return false;
                        });

                        if (match) {
                            if (typeof listener.callback === &quot;function&quot;) {
                                listener.callback.apply(match, args);
                            } else if (listener.callback.handleEvent) {
                                listener.callback.handleEvent.apply(match, args);
                            }
                            return true;
                        }
                        return false;
                    });
                };
                this.bind(type, delegate.handler);
            }
            delegate.listeners.push(listener);
            return this;
        },

<span id='TTWorker-method-undelegate'>        /**
</span>         * Un bind events from HTMLElement
         * To un bind the event of delegate type
         *
         * @method undelegate
         * @chainable
         * @param {String} type
         * @param {String|Function} any
         * @param {Function} callback
         * @return {Object} TTWorker Object
         */
        undelegate: function(type, target, callback) {
            var delegate = this._delegates[type],
                listeners = delegate.listeners;

            if (!listeners || listeners.length === 0) {
                return this;
            }
            tt_match(listeners, function(listener, index) {
                if (listener.target === target &amp;&amp;
                    listener.callback === callback) {
                        listeners.splice(index, 1);
                        return true;
                }
                return false;
            });
            if (listeners.length === 0) {
                this.unbind(type, delegate.handler);
                this._delegates[type] = {};
            }
            return this;
        },

<span id='TTWorker-method-addClass'>        /**
</span>         * Add class name
         *
         * @method addClass
         * @param {String} classname
         * @return {Object} TTWorker object
         */
        addClass: domTester.classList ?
            function(className) {
                return this.each(function() {
                    this.classList.add(className);
                });
            } :
            function _addClassByClassName(className) {
                var stashName = this[0].className,
                    newName = _createName(stashName, className);

                return this.each(function(index) {
                    if (tt(this).hasClass(className)) {
                        return;
                    }
                    if (index &amp;&amp; stashName !== this.className) {
                        stashName = this.className;
                        newName = _createName(stashName, className);
                    }
                    this.className = newName;
                });

                function _createName(currentName, newName) {
                    var res = currentName.split(&quot; &quot;);

                    res[res.length] = newName;
                    return res.join(&quot; &quot;);
                }
            },

<span id='TTWorker-method-removeClass'>        /**
</span>         * Remove class name
         *
         * @method removeClass
         * @param {String} classname
         * @return {Object} TTWorker object
         */
        removeClass: domTester.classList ?
            function _removeClassByClassList(className) {
                return this.each(function() {
                    this.classList.remove(className);
                });
            } :
            function _removeClassByClassName(className) {
                var lastClassName, newClassName;

                className = &quot; &quot; + className + &quot; &quot;;

                return this.each(function() {
                    if (this.className === lastClassName) {
                        this.className = newClassName;
                    } else {
                        lastClassName = this.className;
                        this.className = newClassName = (&quot; &quot; + lastClassName + &quot; &quot;).replace(className, &quot; &quot;).trim();
                    }
                });
            },

<span id='TTWorker-method-hasClass'>        /**
</span>         * Search class name
         *
         * @method hasClass
         * @param {String} classname
         * @return {Object} TTWorker object
         */
        hasClass: domTester.classList ?
            function _hasClassByClassList(className) {
                return this.match(function() {
                    return this.classList.contains(className);
                });
            } :
            function _hasClassByClassName(className) {
                className = &quot; &quot; + className;
                return this.match(function() {
                    return (&quot; &quot; + this.className).indexOf(className) &gt; -1;
                });
            },

<span id='TTWorker-method-toggleClass'>        /**
</span>         * Toggle class name
         *
         * @method toggleClass
         * @param {String} classname
         * @param {Boolean} strict
         * @return {Object} TTWorker object
         */
        toggleClass: function(className, strict) {
            var that = this;

            if (strict) {
                that.each(function() {
                    var target = tt(this);

                    if (target.hasClass(className)) {
                        target.removeClass(className);
                    } else {
                        target.addClass(className);
                    }
                });
            } else {
                if (tt(that[0]).hasClass(className)) {
                    that.removeClass(className);
                } else {
                    that.addClass(className);
                }
            }
            return this;
        },

<span id='TTWorker-method-find'>        /**
</span>         * Find elements under registered elements
         *
         * @method find
         * @param {String} query
         * @return {Object} TTWorker object
         */
        find: function(query) {
            var res = [];

            this.each(function() {
                res = res.concat(tt(query, this).toArray());
            });
            return tt(res);
        },

<span id='TTWorker-method-contains'>        /**
</span>         * Find HTMLElement from registered elements
         *
         * @method contains
         * @param {String|Object} any QueryString, HTMLElement, NodeList
         * @return {HTMLElement} matches HTMLElement
         */
        contains: function(any) {
            var res = tt(),
                target = tt(any);

            this.each(function() {
                var context = this,
                    cond = target.match(function() {
                        return context.contains(this);
                    });

                if (cond) {
                    res.push(this);
                }
            });
            return res;
        },

<span id='TTWorker-method-attr'>        /**
</span>         * Set attribute values
         * Get attributes list or attribute value
         *
         * @method attr
         * @param {String} any QueryString, HTMLElement, NodeList
         * @param {String|Object} value QueryString, HTMLElement, NodeList
         * @return {Object|String} Key-value object of attributes or attribute value
         */
        attr: function(any, value) {
            var that = this;

            switch (arguments.length) {
            case 0:
                var attrs = this[0].attributes, attr;

                any = {};
                for (var i = 0, iz = attrs.length; i &lt; iz; ++i) {
                    attr = attrs[i];
                    any[attr.nodeName] = attr.nodeValue;
                }
                return any;
            case 1:
                if (typeof any === &quot;object&quot;) {
                    tt_each(any, function(key) {
                        _setAttr(key, any[key]);
                    });
                } else {
                    return this[0].getAttribute(any);
                }
                break;
            case 2:
                _setAttr(any, value);
                break;
            }
            return this;

            function _setAttr(key, value) {
                if (value === undefined || value === null) {
                    value = &quot;&quot;;
                }
                that.each(function() {
                    if (value === &quot;&quot;) {
                        this.removeAttribute(key);
                        return;
                    }
                    this.setAttribute(key, value);
                });
            }
        },

<span id='TTWorker-method-html'>        /**
</span>         * Replace html in registered elements
         * or get text html in thier
         *
         * @method html
         * @param {String|HTMLElement} [any] HTMLText, HTMLElement
         * @return {Object|String} Key-value object of attributes or attribute value
         */
        html: function(any) {
            if (any === undefined || any === null) {
                return this[0].innerHTML;
            }

            if (any.nodeType) {
                this.clear().append(any);
            } else {
                this.each(function() {
                    while (this.firstChild) {
                        this.removeChild(this.firstChild);
                    }
                    this.insertAdjacentHTML(&quot;afterbegin&quot;, any);
                });
            }
            return this;
        },

<span id='TTWorker-method-append'>        /**
</span>         * Append HTMLElement or text html to registered elements
         *
         * @method append
         * @param {String|HTMLElement} any HTMLElement, Text html
         * @return {Object} TTWorker object
         */
        append: function(any) {
            var useClone = this.length &gt; 1;

            return this.each((typeof any === &quot;string&quot;) ?
                function() { this.insertAdjacentHTML(&quot;beforeend&quot;, any); } :
                function() {
					var that = this;

					if (any.nodeType) {
						this.appendChild(useClone ? any.cloneNode(true) : any);
					} else if (any instanceof TTWorker) {
						any.each(function() {
							that.appendChild(this);
						});
					}
				});
        },

<span id='TTWorker-method-prepend'>        /**
</span>         * Prepend HTMLElement or text html to registered elements
         *
         * @method prepend
         * @param {String|HTMLElement} any HTMLElement, Text html
         * @return {Object} TTWorker object
         */
        prepend: function(any) {
            var useClone = this.length &gt; 1;

            return this.each((typeof any === &quot;string&quot;) ?
                function() { this.insertAdjacentHTML(&quot;afterbegin&quot;, any); } :
				function() {
					var that = this;

					if (any.nodeType) {
						this.insertBefore(useClone ? any.cloneNode(true) : any, this.firstChild);
					} else if (any instanceof TTWorker) {
						any.each(function() {
							that.insertBefore(this, that.firstChild);
						});
					}
				});
        },

<span id='TTWorker-method-remove'>        /**
</span>         * Remove elements of registered from html
         *
         * @method remove
         * @return {Object} TTWorker object
         */
        remove: function() {
            return this.each(function() {
                this.parentNode.removeChild(this);
            });
        },

<span id='TTWorker-method-clear'>        /**
</span>         * Remove child elements of registered elements
         *
         * @method clear
         * @return {Object} TTWorker object
         */
        clear: function() {
            return this.each(function() {
                while (this.firstChild) {
                    this.removeChild(this.firstChild);
                }
            });
        },

<span id='TTWorker-method-parent'>        /**
</span>         * Get parent element from registered elements
         *
         * @method parent
         * @param {String|Object} any Query string for search elements or TTWorker object
         * @return {Object} TTWorker object
         */
        parent: function(any) {
            var res = tt();

            if (any) {
                var target = tt(any).toArray();

                this.each(function() {
                    if (target.indexOf(this.parentNode) &gt; -1) {
                        res.push(this.parentNode);
                    }
                });
            } else {
                this.each(function() {
                    res.push(this.parentNode);
                });
            }
            return res;
        },

<span id='TTWorker-method-parents'>        /**
</span>         * Get parent elements of the element back in DOM tree from registered elements
         *
         * @method parents
         * @param {String|Object} any Query string for search elements or TTWorker object
         * @return {Object} TTWorker object
         */
        parents: function(any) {
            var that = this,
                res;

            if (any) {
                res = tt();
                tt(any).each(function() {
                    var context = this,
                        match = that.match(function() {
                            var pos = context.compareDocumentPosition(this);

                            return (pos &amp; Node.DOCUMENT_POSITION_CONTAINED_BY);
                        });

                    if (match) {
                        res.push(this);
                    }
                });
            } else {
                res = [];
                this.match(function() {
                    var parent = this;

                    while ((parent = parent.parentNode) !== null) {
                        if (res.indexOf(parent) &lt; 0) {
                            res.push(parent);
                        } else {
                            return true;
                        }
                    }
                    return false;
                });
                res = tt(res);
            }
            return res;
        },

<span id='TTWorker-method-closest'>        /**
</span>         * Get closest element from registered element with query string or target element
         *
         * @method closest
         * @param {String|Object} any Query string for search elements or TTWorker object
         * @return {Object} TTWorker object
         */
        closest: function(any) {
            var res = [],
                target;

            if (!any) {
                return tt();
            }
            target = tt(any).toArray();
            this.each(function() {
                var element = this;

                while (element) {
                    if (target.indexOf(element) &gt; -1) {
                        if (res.indexOf(element) === -1) {
                            res.push(element);
                        }
                        break;
                    }
                    element = element.parentNode;
                }
            });
            return tt(res);
        },

<span id='TTWorker-method-children'>        /**
</span>         * Get child elements from registered elements
         *
         * @method children
         * @param {String|Object} [any] QueryString, HTMLElement, NodeList
         * @return {Object} tt object of matches child HTMLElements
         */
        children: function(any) {
            var res,
                target;

            if (any) {
                res = tt();
                target = tt(any);
                this.each(function() {
                    var children = [].slice.call(this.children),
                        iz = children.length;

                    target.each(function() {
                        var child, i;

                        for (i = 0; i &lt; iz; ++i) {
                            child = children[i];
                            if (this === child) {
                                res.push(child);
                            }
                        }
                    });
                });
            } else {
                res = [];
                this.each(function() {
                    res = res.concat([].slice.call(this.children));
                });
                res = tt(res);
            }
            return res;
        },

<span id='TTWorker-method-replace'>        /**
</span>         * Replace elements of registered elements
         *
         * @method replace
         * @param {String|HTMLElement} any text html or HTMLElement
         * @return {Object} TTWorker object
         */
        replace: function(any) {
            this.each((typeof any === &quot;string&quot;) ?
                function() { this.insertAdjacentHTML(&quot;beforebegin&quot;, any); } :
                function() { this.parentNode.insertBefore(any, this); });
            return this.remove();
        },

<span id='TTWorker-method-css'>        /**
</span>         * Set or get css styles
         *
         * @method css
         * @param {String|Object} [any] CSS property name, object of CSS style set
         * @param {String|Number} [value] CSS style value
         * @return {String|Number|Object} css style value or CSSStyleDeclaration object
         */
        css: function(any, value) {
            var that = this;

            if (typeof any === &quot;object&quot;) {
                tt_each(any, function(key, val) {
                    if (val === &quot;&quot;) {
                        _removeProperty(key);
                        return;
                    }
                    _setStyle(tt_camelizer(key), val);
                });
            } else if (any) {
                if (value) {
                    _setStyle(tt_camelizer(any), value);
                } else if (value === &quot;&quot;) {
                    _removeProperty(any);
                } else {
                    return global.getComputedStyle(this[0]).getPropertyValue(any);
                }
            } else {
                return global.getComputedStyle(this[0]);
            }

            return this;

            function _removeProperty(prop) {
                that.each(function() {
                    this.style.removeProperty(prop);
                });
            }

            function _setStyle(prop, val) {
                that.each(function() {
                    this.style[prop] = val;
                });
            }
        },

<span id='TTWorker-method-data'>        /**
</span>         * Set or get elements dataset
         * If the array or object, data type passed to save the _data object of instance
         *
         * @method data
         * @param {String|Object} [any] CSS property name, object of CSS style set
         * @param {String|Number} [value] CSS style value
         * @return {String|Number|Object} data value or data values object
         */
        data: (function() {
            var cond = domTester.dataset,
                _getDataAttr = cond ? _getDataByDataset : _getDataByAttributes,
                _setDataAttr = cond ? _setDataByDataset : _setDataByAttributes;

            return function (any, value) {
                var that = this,
                    key;

                switch (arguments.length) {
                case 0:
                    return _getDataAttr.call(this);
                case 1:
                    if (typeof any === &quot;object&quot;) {
                        tt_each(any, function(key, val) {
                            _setDataAttr.call(that, key, val);
                        });
                        return this;
                    } else {
                        return _getDataAttr.call(this, any);
                    }
                    break;
                case 2:
                    _setDataAttr.call(this, any, value);
                    return this;
                }
            };

            function _setDataByDataset(key, val) {
                var type = tt_type(val),
                    func = null;

                if (val === &quot;&quot; ||
                    type === &quot;undefined&quot; ||
                    type === &quot;null&quot;) {
                        if (this._data[key]) {
                            delete this._data[key];
                            return;
                        } else {
                            func = function() { delete this.dataset[key]; };
                        }
                } else if (type === &quot;string&quot; || type === &quot;number&quot;) {
                    func = function() { this.dataset[key] = val; };
                } else {
                    this._data[key] = val;
                    return;
                }
                this.each(func);
            }

            function _getDataByDataset(key) {
                if (!this[0]) {
                    return null;
                }
                var node = this[0],
                    res = {};

                if (key) {
                    if (this._data[key]) {
                        return this._data[key] || null;
                    } else {
                        return node.dataset[key] || null;
                    }
                } else {
                    tt_each(node.dataset, function(key, val) {
                        res[key] = val;
                    });
                    tt_extend(res, this._data);
                }
                return res;
            }

            function _setDataByAttributes(key, val) {
                var type = tt_type(val);

                if (tt_type(val, [&quot;string&quot;, &quot;number&quot;, &quot;undefined&quot;, &quot;null&quot;])) {
                    if (val === &quot;&quot; &amp;&amp; this._data[key]) {
                        delete this._data[key];
                        return null;
                    }
                    this.attr(&quot;data-&quot; + key, val);
                } else {
                    this._data[key] = val;
                }
            }

            function _getDataByAttributes(key) {
                if (!this[0]) {
                    return null;
                }
                var res = {},
                    dataName = &quot;data-&quot;,
                    node = this[0],
                    attr, attrs = node.attributes,
                    i = 0, iz = attrs.length;

                if (!node) {
                    return null;
                } else if (this._data[key]) {
                    return this._data[key];
                } else if (key) {
                    dataName += key;
                    return this.attr(dataName);
                }
                for (; i &lt; iz; ++i) {
                    attr = attrs[i].name;
                    if (attr.indexOf(dataName) &gt; -1) {
                        key = attr.substr(5, attr.length);
                        res[key] = attrs[i].value;
                    }
                }
                tt_each(this._data, function(key, val) {
                    res[key] = val;
                });
                return res;
            }
        })(),

<span id='TTWorker-method-val'>        /**
</span>         * Set, get &quot;value&quot; attributes value of registered elements
         *
         * @method val
         * @param {String|Number} [value]
         * @return {Object|String|Array} TTWorker object, value or values list
         */
        val: function(value) {
            if (value !== undefined) {
                this.each(function() {
                    if (this.value !== undefined) {
                        this.value = value;
                    }
                });
                return this;
            } else {
                var res = [];

                this.each(function(index) {
                    if (this.value !== undefined) {
                        res[index] = this.value;
                    }
                });
                return this.length &gt; 1 ? res : res[0];
            }
        },

<span id='TTWorker-method-show'>        /**
</span>         * Show elements, if it is hide curretly
         *
         * @method show
         * @param {String|Object} [options] value CSS value of display property
         * @return {Object} tt object
         */
        show: function(value) {
            var currentValue = this.css(&quot;display&quot;),
                lastValue = this._data.lastDisplay || null;

            if (currentValue !== &quot;none&quot;) {
                return;
            }
            return this.css(&quot;display&quot;, value || lastValue || &quot;block&quot;);
        },

<span id='TTWorker-method-hide'>        /**
</span>         * Hide elements, if it is show currently
         *
         * @method hide
         * @return {Object} tt object
         */
        hide: function() {
            var currentValue = this.css(&quot;display&quot;);

            if (currentValue !== &quot;none&quot;) {
                this._data.lastDisplay = currentValue;
            }
            return this.css(&quot;display&quot;, &quot;none&quot;);
        },

<span id='TTWorker-method-trigger'>        /**
</span>         * Trigger events for registered elements
         *
         * @method trigger
         * @chainable
         * @param {String} name event type name
         * @param {String} [data..] Data to pass to event
         * @return {Object} tt object
         */
        trigger: function(/* name[, data..] */) {
            var args = [].slice.call(arguments),
                name = args.shift(),
                ev = document.createEvent(&quot;Event&quot;);

            ev.initEvent(name, true, true);
            if (args.length &gt; 1) {
                ev._tt_data = args;
            }
            this.each(function() {
                this.dispatchEvent(ev);
            });
            return this;
        },

<span id='TTWorker-method-offset'>        /**
</span>         * Get offset position of registered elements
         * Ex.
         *  document.body
         *  +--------------------------
         *  |             |
         *  |            top
         *  |             v
         *  | -- left --&gt; +---------+
         *  |             | Element |
         *  |             +---------+
         *  |
         *
         * @method offset
         * @return {Object|Array} {left: Number, top: Number} or their array
         */
        offset: function() {
            var res = [];

            this.each(function(index) {
                var offset = this.getBoundingClientRect();

                res[index] = {
                    left: offset.left + global.pageXOffset,
                    top: offset.top + global.pageYOffset
                };
            });
            return this.length === 1 ? res[0] : res;
        },

<span id='TTWorker-method-width'>        /**
</span>         * Get width from registered elements
         *
         * @method width
         * @param {Number} [index] number of registered elements
         * @return {Number} number of element width
         */
		width: function(index) {
			return this[index || 0].offsetWidth;
		},

<span id='TTWorker-method-height'>        /**
</span>         * Get height from registered elements
         *
         * @method height
         * @param {Number} [index] number of registered elements
         * @return {Number} number of element height
         */
		height: function(index) {
			return this[index || 0].offsetHeight;
		}
    };

    // globalize
    global[IDENT] = global[IDENT] || tt;

})((this.self || global), document);

</pre>
</body>
</html>
