<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src&#x2F;tt.js - tt</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="tt"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.5.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/tt.html">tt</a></li>
            
                <li><a href="..&#x2F;classes/TTCreater.html">TTCreater</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src&#x2F;tt.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
;(function(global, document, undefined) {
    &quot;use strict&quot;;

    var IDENT = &quot;tt&quot;,
        querySelectorRe = &#x2F;^(.+[\#\.\s\[\*&gt;:,]|[\[:])&#x2F;,
        loaded = false,
        loadQueue = [],
        env = tt_createEnvData(global.navigator),
        domTester = document.createElement(&quot;div&quot;);

    &#x2F;&#x2F; call load callback queue
    document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
        loaded = true;
        for (var i = 0, iz = loadQueue.length; i &lt; iz; ++i) {
            loadQueue[i]();
        }
    }, false);

    &#x2F;&#x2F; for old android compatiblity
    &#x2F;&#x2F; Object.keys shim - MDN https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Object&#x2F;keys#Compatiblity
    if (!Object.keys) {
        Object.keys=(function(){var a=Object.prototype.hasOwnProperty,b=!{toString:null}.propertyIsEnumerable(&quot;toString&quot;),c=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=c.length;return function(e){if(&quot;object&quot;!==typeof e&amp;&amp;&quot;function&quot;!==typeof e||null===e){throw new TypeError(&quot;Object.keys called on non-object&quot;);}var f=[];for(var g in e){if(a.call(e,g)){f.push(g);}}if(b){for(var h=0;d&gt;h;h++){if(a.call(e,c[h])){f.push(c[h]);}}}return f;};})();
    }
    &#x2F;&#x2F; Array.isArray shim
    if (!Array.isArray) {
        Array.isArray=function(a){return Object.prototype.toString.call(a)===&quot;[object Array]&quot;;};
    }
    &#x2F;&#x2F; String.prototype.trim = MDN https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en&#x2F;docs&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;String&#x2F;trim#Compatibility
    if (!String.prototype.trim) {
        String.prototype.trim=function(){return this.replace(&#x2F;^\s+|\s+$&#x2F;g,&quot;&quot;);};
    }
    &#x2F;&#x2F; Node.contains shim
    if (!Node.contains) {
        Node.contains=function(a){var b=this.compareDocumentPosition(a);return (b===0||b&amp;Node.DOCUMENT_POSITION_CONTAINED_BY);};
    }

    &#x2F;**
     * tt.js main function
     *
     * This function does the following arguments to be passed by
     *
     * ### CSSQueryString, NodeElement, NodeList or its like Array, document or document.body, tt object
     * &gt;&gt; Create tt class object (DOM Operator)
     *
     * ### Function
     * &gt;&gt; If the HTML is already loaded is executed immediately, if not already loaded is executed at the timing of the DOMContentLoaded
     *
     * @class tt
     * @param {String|Function|Node|NodeList|NodeList like Array|document|document.body} mix
     * @param {Node} [options] parent If first params is String, sets the parent of the search target
     * @return {Object|undefined} Return tt object of if first params is Function return undefined
     *&#x2F;
    function tt(mix, parent) {
        var target = null,
            selector = &quot;&quot;;

        if (typeof mix === &quot;string&quot;) {
            selector = mix;
            parent = parent || document;
            target = querySelectorRe.test(mix) ?
                        parent.querySelectorAll(mix) :
                     mix[0] === &quot;#&quot; ?
                        [parent.getElementById(mix.substring(1, mix.length))] :
                     mix[0] === &quot;.&quot; ?
                        parent.getElementsByClassName(mix.substring(1, mix.length)) :
                        parent.getElementsByTagName(mix);
        } else if (mix) {
            if (mix.nodeType === 1) {
                target = [mix];
            } else if (tt_isNodeList(mix) ||
                      (Array.isArray(mix) &amp;&amp; mix.length &amp;&amp; mix[0].nodeType)) {
                target = mix;
            } else if (mix === document || mix === document.body) {
                target = [document.body];
            } else if (typeof mix === &quot;function&quot;) {
                if (loaded) {
                    mix();
                } else {
                    loadQueue.push(mix);
                }
                return;
            } else if (mix instanceof TTCreater) {
                return mix;
            }
        }
        return new TTCreater(target || [], selector);
    }

    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; static methods
    tt.ajax          = tt_ajax;
    tt.createEnvData = tt_createEnvData;
    tt.camelizer     = tt_camelizer;
    tt.hyphenizer    = tt_hyphenizer;
    tt.cssPrefix     = tt_cssPrefix;
    tt.each          = tt_each;
    tt.extend        = tt_extend;
    tt.env           = env;
    tt.isArray       = Array.isArray;
    tt.isNodeList    = tt_isNodeList;
    tt.match         = tt_match;
    tt.param         = tt_param;
    tt.parseJSON     = tt_parseJSON;
    tt.proxy         = tt_proxy;
    tt.query2object  = tt_query2object;
    tt.tag           = tt_tag;
    tt.triggerEvent  = tt_triggerEvent;
    tt.type          = tt_type;

    &#x2F;&#x2F;&#x2F;&#x2F; Iterate functions
    &#x2F;**
     * Execute iterate a function from array or object
     *
     * @method tt.each
     * @static
     * @param {Array|Object} mix target to pass to a function
     * @param {Function} fn function to execute iteratively
     *&#x2F;
    function tt_each(mix, fn) {
        var arr, key,
            i = 0, iz;

        if (Array.isArray(mix)) {
            iz = mix.length;
            for (; i &lt; iz; ++i) {
                fn(mix[i], i);
            }
        } else if (typeof mix === &quot;object&quot;) {
            arr = Object.keys(mix);
            iz = arr.length;
            for (; i &lt; iz; ++i) {
                key = arr[i];
                fn(key, mix[key]);
            }
        }
    }

    &#x2F;**
     * Extend target object with each objects
     * If first argument is true, will be recursive copy
     *
     * @method tt.extend
     * @static
     * @param {Object|Bool} any first target object or deep flag
     * @param {Object} [options] override objects
     * @return {Object} result object
     *&#x2F;
    function tt_extend() {
        var args = [].slice.call(arguments),
            i = 1, iz = args.length,
            deep = false,
            arg, target;

        if (args[0] === true) {
            deep = true;
            ++i;
        }
        target = args[(i - 1)] || {};

        for (; i &lt; iz; ++i) {
            arg = args[i];
            if (tt_type(arg) !== &quot;object&quot;) {
                continue;
            }
            tt_each(Object.keys(arg), _extend);
        }
        return target;

        function _extend(key, index) {
            if (deep &amp;&amp;
                tt_type(target[key], &quot;object&quot;) &amp;&amp;
                tt_type(arg[key], &quot;object&quot;)) {
                    tt_extend(target[key], arg[key]);
            } else {
                target[key] = arg[key];
            }
        }
    }

    &#x2F;**
     * Execute iterate a function from array or object
     *
     * @method tt.match
     * @static
     * @param {Array|Object} mix target to pass to a function
     * @param {Function} fn function to execute iteratively
     *&#x2F;
    function tt_match(mix, fn) {
        var arr,
            key, res = {},
            i = 0, iz;

        if (Array.isArray(mix)) {
            iz = mix.length;
            for (; i &lt; iz; ++i) {
                if (fn(mix[i], i)) {
                    return mix[i];
                }
            }
        } else if (typeof mix === &quot;object&quot;) {
            arr = Object.keys(mix);
            iz = arr.length;
            for (; i &lt; iz; ++i) {
                key = arr[i];
                if (fn(key, mix[key], i)) {
                    res[key] = mix[key];
                    return res;
                }
            }
        }
        return null;
    }


    &#x2F;&#x2F;&#x2F;&#x2F; detect type functions
    &#x2F;**
     * Detect array strictly
     *
     * @method tt.isNodeList
     * @static
     * @param {Any} target detect target
     * @return {Bool} result
     *&#x2F;
    function tt_isNodeList(mix) {
        var type=Object.prototype.toString.call(mix);

        return type === &quot;[object NodeList]&quot; || type === &quot;[object HTMLCollection]&quot;;
    }

    &#x2F;**
     * Return target type
     * If matches is passed and returns result of comparing target
     *
     * @method tt.type
     * @static
     * @param {Any} target judgment target
     * @param {String|Array} matches List, or string type to be compared
     * @return {Bool} result
     *&#x2F;
    function tt_type(target, matches) {
        var res = target === null       ? &quot;null&quot; :
                  target === void 0     ? &quot;undefined&quot; :
                  target === global     ? &quot;global&quot; :
                  target === document   ? &quot;document&quot; :
                  target.nodeType       ? &quot;node&quot; :
                  Array.isArray(target) ? &quot;array&quot; :
                  tt_isNodeList(target) ? &quot;nodelist&quot; : undefined;

        if (!res) {
            res = typeof target;
            if (res === &quot;object&quot;) {
                res = Object.prototype.toString.call(target).toLowerCase().match(&#x2F;.*\s([a-z]*)\]&#x2F;)[1];
            }
        }
        if (!matches) {
            return res;
        } else if (Array.isArray(matches)) {
            for (var i = 0, iz = matches.length; i &lt; iz; ++i) {
                if (matches[i] === res) {
                    return true;
                }
            }
            return false;
        } else {
            return matches === res;
        }
    }


    &#x2F;&#x2F;&#x2F;&#x2F; useful functions
    &#x2F;**
     * XMLHttpRequest wrapper method
     *
     * @method tt.ajax
     * @static
     * @param {String|Object} mix request url or setting object
     * @param {Object} [options] setting setting object
     * @return {Object} XMLHttpRequest object
     *&#x2F;
    function tt_ajax(mix, setting) {
        var called = false,
            xhr = new XMLHttpRequest();

        setting = setting || {};
        if (tt_type(mix, &quot;object&quot;)) {
            setting = mix;
        } else if (tt_type(mix, &quot;string&quot;)) {
            setting.url = mix;
        } else {
            throw new Error(&quot;Error: missing argument&quot;);
        }

        setting = tt_extend({
            async       : true,
            beforeSend  : null,
            cache       : true,
            complete    : null,
            contentType : &quot;application&#x2F;x-www-form-urlencoded; charset=UTF-8&quot;,
            context     : document.body,
            data        : null,
            dataType    : &quot;text&quot;,
            error       : null,
            headers     : null,
            mimeType    : null,
            success     : null,
            timeout     : 0,
            type        : &quot;GET&quot;,
            url         : &quot;&quot;,
            user        : &quot;&quot;,
            password    : &quot;&quot;
        }, setting);

        setting.type = setting.type.toUpperCase();

        if (setting.data &amp;&amp; setting.type === &quot;GET&quot;) {
            setting.url =
                setting.url +
                setting.url.indexOf(&quot;?&quot;) &gt; -1 ? &quot;&amp;&quot; : &quot;?&quot; +
                tt_param(setting.data);
            setting.data = null;
        } else {
            setting.data = tt_param(setting.data);
        }

        xhr.onerror = function() {
            _callCallbacks(0);
        };

        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
                _callCallbacks(xhr.status);
            }
        };

        xhr.open(setting.type,
                 setting.url,
                 setting.async,
                 setting.user,
                 setting.password);

        if (setting.type === &quot;POST&quot;) {
            xhr.setRequestHeader(&quot;Content-type&quot;, setting.contentType);
            xhr.setRequestHeader(&quot;Content-length&quot;, setting.data.length);
        }
        if (tt_type(setting.headers, &quot;object&quot;)) {
            tt_each(setting.headers, function(key, value) {
                xhr.setRequestHeader(key, value);
            });
        }
        if (setting.dataType) {
            try {
                xhr.responseType = setting.dataType;
            } catch (e) {
                xhr.responseType = &quot;text&quot;;
            }
        }
        if (setting.mimeType) {
            xhr.overrideMimeType(setting.mimeType) ;
        }
        if (setting.beforeSend) {
            setting.beforeSend(xhr);
        }
        if (setting.timeout) {
            xhr.timeout = setting.timeout;
        }
        xhr.send(setting.data);

        return xhr;

        function _callCallbacks(statusCode) {
            if (called) {
                return;
            }
            called = true;

            var res, context = setting.context;

            if (statusCode &gt;= 200 &amp;&amp; statusCode &lt; 400) {
                res = xhr.response || xhr.responseText;
                if (setting.dataType === &quot;json&quot; &amp;&amp; tt_type(res, &quot;string&quot;)) {
                    res = tt_parseJSON(res);
                }
                if (setting.success) {
                    setting.success.apply(context, [res, statusCode, xhr]);
                }
            } else {
                if (setting.error) {
                    setting.error.apply(context, [xhr, statusCode]);
                }
            }
            if (setting.complete) {
                setting.complete.apply(context, [xhr, statusCode]);
            }
            xhr = null;
        }
    }

    &#x2F;**
     * Create an object of environmental information based on the information of the navigator
     *
     * Environmental information can be obtained based on the following key
     *
     * Decision os:         ios, android, windowsPhone
     *
     * Decision browsers:   mobileSafari, androidBrowser, chrome, firefox, opera, ie, other
     *
     * version information: (only mobileSafari androidBrowser)
     *
     *                      version(raw data)
     *
     *                      versionCode(version number of 4-digit or higher)
     *
     * @method tt.createEnvData
     * @static
     * @param {Navigator} navigator object
     * @return {Object} object
     *&#x2F;
    function tt_createEnvData(nav) {
        var res = {},
            ua = (nav || global.navigator).userAgent.toLowerCase();

        res.android = &#x2F;android&#x2F;.test(ua);
        res.ios = &#x2F;ip(hone|od|ad)&#x2F;.test(ua);

        if (!res.android &amp;&amp; !res.ios) {
            res.windowsPhone = &#x2F;windows\sphone&#x2F;.test(ua);
            res.ie = &#x2F;msie&#x2F;.test(ua);
        }

        res.chrome = &#x2F;(chrome|crios)&#x2F;.test(ua);
        res.firefox = &#x2F;firefox&#x2F;.test(ua);
        res.opera = &#x2F;opera&#x2F;.test(ua);
        res.androidBrowser = !res.chrome &amp;&amp; res.android &amp;&amp; &#x2F;applewebkit&#x2F;.test(ua);
        res.mobileSafari = !res.chrome &amp;&amp; res.ios &amp;&amp; &#x2F;applewebkit&#x2F;.test(ua);

        res.version =
            (res.androidBrowser || res.android &amp;&amp; res.chrome) ? ua.match(&#x2F;android\s(\S.*?)\;&#x2F;) :
            (res.mobileSafari || res.ios &amp;&amp; res.chrome) ? ua.match(&#x2F;os\s(\S.*?)\s&#x2F;) :
            null;
        res.version = res.version ?
            res.ios ?
                res.version[1].replace(&quot;_&quot;, &quot;.&quot;) :
                res.version[1] :
            null;
        res.versionCode = _getVersionCode(res.version);
        res.supportTouch = &quot;ontouchstart&quot; in global;

        return res;

        function _getVersionCode(version) {
            if (!version) {
                return null;
            }
            var res, digit = 4, diff = 0;

            version = version.replace(&#x2F;\D&#x2F;g, &quot;&quot;);
            diff = digit - version.length;

            if (diff &gt; 0) {
                res = (+version) * Math.pow(10, diff);
            } else {
                res = +version;
            }
            return res;
        }
    }

    &#x2F;**
     * Get string CSS camel case from string of CSS hyphen case
     *
     * @method tt.camelizer
     * @static
     * @param {String} str CSS property value
     * @return {String}
     *&#x2F;
    function tt_camelizer(str) {
        if (!str || typeof str !== &quot;string&quot;) {
            throw new Error(&quot;Error: argument error&quot;);
        }
        var res = &quot;&quot;;

        if (str[0] === &quot;-&quot;) {
            str = str.substr(1, str.length);
        }
        tt.each(str.split(&quot;-&quot;), function(value, index) {
            if (!index) {
                res += value;
                return;
            }
            res += value[0].toUpperCase() + value.substr(1, value.length);
        });
        return res || str;
    }

    &#x2F;**
     * Get value of CSS with a prefix
     *
     * @method tt.cssPrefix
     * @static
     * @param {String} value CSS value
     * @param {Array} prefix additional prefixes list
     * @return {Array}
     *&#x2F;
    function tt_cssPrefix(value, prefix) {
        var res = [];

        prefix = prefix || [&quot;webkit&quot;, &quot;moz&quot;, &quot;o&quot;, &quot;ms&quot;, &quot;khtml&quot;];
        tt_each(prefix, function(str, index) {
            res[index] = &quot;-&quot; + str + &quot;-&quot; + value;
        });
        return res;
    }

    &#x2F;**
     * Get string CSS hyphen case from string of CSS camel case
     *
     * @method tt.hyphenizer
     * @static
     * @param {String} str CSS property value
     * @return {String}
     *&#x2F;
    function tt_hyphenizer(str) {
        if (!str || typeof str !== &quot;string&quot;) {
            throw new Error(&quot;Error: argument error&quot;);
        }
        var prefix = [&quot;webkit&quot;, &quot;moz&quot;, &quot;o&quot;, &quot;ms&quot;, &quot;khtml&quot;],
            upperRe = &#x2F;[A-Z]&#x2F;g,
            upperStr = str.match(upperRe),
            res = &quot;&quot;;

        tt_each(str.split(upperRe), function(value, index) {
            if (prefix.indexOf(value) &gt; -1) {
                res += &quot;-&quot; + value;
                return;
            } else if (!index) {
                res += value;
                return;
            }
            res += (&quot;-&quot; + upperStr.shift().toLowerCase() + value);
        });
        return res || str;
    }

    &#x2F;**
     * Parse query string to object
     *
     * @method tt.query2object
     * @static
     * @param {String} query query string
     * @return {Object} result
     *&#x2F;
    function tt_param(obj) {
        if (!tt_type(obj, &quot;object&quot;)) {
            return obj;
        }
        var key, keys = Object.keys(obj),
            i = 0, iz = keys.length,
            results = [];

        for (;i &lt; iz; ++i) {
            key = keys[i];
            results.push(encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(obj[key]));
        }
        return results.join(&quot;&amp;&quot;);
    }

    &#x2F;**
     * Parse string of json to json object
     *
     * @method tt.parseJSON
     * @static
     * @param {String} text parse target string
     * @return {Function} Callback function
     *&#x2F;
    function tt_parseJSON(text) {
        if (!text) {
            return {};
        } else if (typeof text === &quot;object&quot;) {
            return text;
        }
        &#x2F;&#x2F; idea from twitter@uupaa
        var obj;

        try {
            obj = JSON.parse(text);
            return obj;
        } catch (p_o) {}
        try {
            &#x2F;*jshint evil: true *&#x2F;
            obj = (new Function(&#x27;return &#x27; + text))();
        } catch (o_q) {
            throw new Error(&quot;Error: can&#x27;t parse text to json&quot;);
        }
        return obj;
    }

    &#x2F;**
     * Returns a function and arguments hold any context
     *
     * @method tt.proxy
     * @static
     * @param {Function} func
     * @param {Any} context
     * @param {Any} [options] args
     * @return {Function} Callback function
     *&#x2F;
    function tt_proxy() {
        if (arguments.length &lt; 2) {
            throw new Error(&quot;Error: missing argument error&quot;);
        }
        var args = [].slice.call(arguments),
            func = args.shift(),
            context = args.shift(),
            tmp;

        if (typeof context === &quot;string&quot;) {
            tmp = func[context];
            context = func;
            func = tmp;
        }
        return function() {
            return func.apply(context, args);
        };
    }

    &#x2F;**
     * Parse query string to object
     *
     * @method tt.query2object
     * @static
     * @param {String} query query string
     * @return {Object} result
     *&#x2F;
    function tt_query2object(query) {
        if (!tt_type(query, &quot;string&quot;)) {
            return {};
        }
        if (query[0] === &quot;?&quot;) {
            query = query.substr(1, query.length);
        }
        var result = {},
            pair = query.split(&quot;&amp;&quot;),
            i = 0, iz = pair.length;

        for (; i &lt; iz; ++i) {
            var k_v = pair[i].split(&quot;=&quot;);

            result[k_v[0]] = k_v[1];
        }
        return result;
    }

    &#x2F;**
     * Create Node or tt object which involve it
     *
     * @method tt.tag
     * @static
     * @param {String} query query string
     * @param {Bool} raw
     * @return {Object} result
     *&#x2F;
    function tt_tag(name, createTT) {
        if (!name || typeof name !== &quot;string&quot;) {
            throw new Error(&quot;Error: argument error&quot;);
        }
        var tag = document.createElement(name);

        return createTT ? tt(tag) : tag;
    }

    &#x2F;**
     * Trigger event to target element
     *
     * @method tt.triggerEvent
     * @static
     * @param {Node} query string
     * @param {String} query string
     * @param {String} query string
     * @param {Bool} query string
     * @param {Bool} query string
     * @return {Object} result
     *&#x2F;
    function tt_triggerEvent(node, event, type, bubbles, cancelable) {
        if (!node || !event) {
            throw new Error(&quot;Error: missing argument error&quot;);
        }
        if (!tt_type(type, &quot;string&quot;)) {
            type = event;
            event = type === &quot;click&quot; ? &quot;MouseEvents&quot; : &quot;Event&quot;;
        }
        var ev = document.createEvent(event);

        ev.initEvent(type,
                     bubbles !== undefined ? bubbles : true,
                     cancelable !== undefined ? cancelable : true);
        node.dispatchEvent(ev);
    }


    &#x2F;**
     * tt.js class creater
     *
     * @class TTCreater
     * @constructor
     * @param {Array|NodeList} nodes NodeList or Array incorporates elements
     * @param {String} selector selector text
     *&#x2F;
    function TTCreater(nodes, selector) {
        var i = 0, iz;

        &#x2F;**
         * Selector text
         *
         * @property selector
         * @type String
         *&#x2F;
        this.selector = selector;

        &#x2F;**
         * Length of registered elements
         *
         * @property length
         * @type Number
         *&#x2F;
        this.length = iz = nodes.length;

        &#x2F;**
         * Event registration information of this tt object
         *
         * @property _events
         * @type Object
         * @private
         *&#x2F;
        this._events = {};

        &#x2F;**
         * Delegate registration information of this tt object
         *
         * @property _delegates
         * @type Object
         * @private
         *&#x2F;
        this._delegates = {};

        &#x2F;**
         * Data for this tt object
         *
         * @property _data
         * @type Object
         * @private
         *&#x2F;
        this._data = {};

        for (; iz; ++i, --iz) {
            this[i] = nodes[i];
        }
        return this;
    }

    tt.fn = TTCreater.prototype = {
        constructor: TTCreater,

        &#x2F;**
         * Returns elements
         *
         * @method get
         * @param {Number} index elements index
         * @return {NodeElement} registered NodeElement
         *&#x2F;
        get: function(index) {
            return this[index || 0];
        },

        &#x2F;**
         * Returns array in elements
         *
         * @method toArray
         * @return {Array} registered elements
         *&#x2F;
        toArray: function() {
            var arr = [];

            this.each(function(index) {
                arr[index] = this;
            });
            return arr;
        },

        &#x2F;**
         * Call function with context of NodeElement and parameter of elements index number
         *
         * @method each
         * @param {Function} fn Function to be executed repeatedly
         * @return {Object} TT object
         *&#x2F;
        each: function(fn) {
            var i = 0, iz = this.length;

            for (; iz; ++i, --iz) {
                fn.call(this[i], i);
            }
            return this;
        },

        &#x2F;**
         * Call function with context of NodeElement and parameter of elements index number
         * If it returns true, then this function return context that matches
         *
         * @method match
         * @param {Function} fn Function to be executed repeatedly
         * @return {Object} TT Object
         *&#x2F;
        match: function(fn) {
            var i = 0, iz = this.length;

            for (; iz; ++i, --iz) {
                if (fn.call(this[i], i)) {
                    return this[i];
                }
            }
            return null;
        },

        &#x2F;**
         * Push element(s) to TT Object
         *
         * @method push
         * @param {Node|NodeList|Array} mix element or elements list
         * @return {Object} TT Object
         *&#x2F;
        push: function(mix) {
            if (mix &amp;&amp; mix.nodeType) {
                this[this.length] = mix;
                ++this.length;
            } else if (tt_type(mix, [&quot;array&quot;, &quot;nodelist&quot;])) {
                var i = this.length, iz = i + mix.length;

                for (; iz; ++i, --iz) {
                    this[i] = mix[i];
                }
            }
            return this;
        },

        &#x2F;**
         * Get index of registered element
         *
         * @method indexOf
         * @param {Node} node serach target element
         * @return {Number} index number
         *&#x2F;
        indexOf: function(node) {
            var res = -1;

            this.match(function(index) {
                if (this === node) {
                    res = index;
                    return true;
                }
                return false;
            });
            return res;
        },

        &#x2F;**
         * Bind events to NodeElement
         *
         * @method on
         * @param {String} type
         * @param {String|Function} mix
         * @param {Function} [options] callback
         * @return {Object} TT Object
         *&#x2F;
        on: function(type, mix, callback) {
            if (tt_type(mix, &#x27;string&#x27;)) {
                this.delegate(type, mix, callback);
            } else {
                this.bind(type, mix);
            }
            return this;
        },

        &#x2F;**
         * Un bind events from NodeElement
         *
         * @method off
         * @param {String} type
         * @param {String|Function} mix
         * @param {Function} callback
         * @return {Object} TT Object
         *&#x2F;
        off: function(type, mix, callback) {
            if (tt_type(mix, &#x27;string&#x27;)) {
                this.undelegate(type, mix, callback);
            } else {
                this.unbind(type, mix);
            }
            return this;
        },

        &#x2F;**
         * Bind events to NodeElement
         * This is simply wrapper of addEventListener
         *
         * @method bind
         * @param {String} type
         * @param {Function|Object} callback
         * @param {Bool} [options] capture
         * @return {Object} TT Object
         *&#x2F;
        bind: function(type, mix, capture) {
            capture = capture || false;
            var self = this,
                event = this._events[type];

            if (!event) {
                event = this._events[type] = {};
                event.callbacks = [];
                event.handler = function(ev) {
                    var data = ev._tt_data,
                        args = Array.isArray(data) ?
                                [].concat(data) : [];

                    args.unshift(ev);
                    tt_each(event.callbacks, function(callback) {
                        if (typeof callback === &quot;function&quot;) {
                            callback.apply(ev.currentTarget, args);
                        } else if (callback &amp;&amp; callback.handleEvent) {
                            callback.handleEvent.apply(ev.currentTarget, args);
                        }
                    });
                };
                this.each(function() {
                    this.addEventListener(type, event.handler, capture);
                });
            }
            event.callbacks.push(mix);
            return this;
        },

        &#x2F;**
         * Un bind events from NodeElement
         * This is simply wrapper of removeEventListener
         *
         * @method unbind
         * @param {String} type
         * @param {Function|Object} mix
         * @return {Object} TT Object
         *&#x2F;
        unbind: function(type, mix) {
            var event = this._events[type],
                index = event ?
                        event.callbacks.indexOf(mix) : -1;

            if (!event || index === -1) {
                return;
            }
            event.callbacks.splice(index, 1);
            if (!event.callbacks.length) {
                this.each(function() {
                    this.removeEventListener(type, event.handler);
                });
            }
            return this;
        },

        &#x2F;**
         * Bind events to NodeElement
         * To bind the event of delegate type
         *
         * @method delegate
         * @param {String} type
         * @param {String|Object} target
         * @param {Function|Object} callback
         * @return {Object} TT Object
         *&#x2F;
        delegate: function(type, target, callback) {
            var delegate = this._delegates[type],
                listener = {
                    target: target,
                    callback: callback
                };

            if (!delegate) {
                delegate = this._delegates[type] = {};
                delegate.listeners = [];
                delegate.handler = function(ev) {
                    var event,
                        eventTarget = ev.target,
                        args = arguments;

                    tt_match(delegate.listeners, function(listener) {
                        var match = tt(listener.target).match(function() {
                            if (this.contains(eventTarget)) {
                                return true;
                            }
                            return false;
                        });

                        if (match) {
                            if (typeof listener.callback === &quot;function&quot;) {
                                listener.callback.apply(match, args);
                            } else if (listener.callback.handleEvent) {
                                listener.callback.handleEvent.apply(match, args);
                            }
                            return true;
                        }
                        return false;
                    });
                };
                this.bind(type, delegate.handler);
            }
            delegate.listeners.push(listener);
            return this;
        },

        &#x2F;**
         * Un bind events from NodeElement
         * To un bind the event of delegate type
         *
         * @method undelegate
         * @param {String} type
         * @param {String|Function} mix
         * @param {Function} callback
         * @return {Object} TT Object
         *&#x2F;
        undelegate: function(type, target, callback) {
            var delegate = this._delegates[type],
                listeners = delegate.listeners;

            if (!listeners || listeners.length === 0) {
                return this;
            }
            tt_match(listeners, function(listener, index) {
                if (listener.target === target &amp;&amp;
                    listener.callback === callback) {
                        listeners.splice(index, 1);
                        return true;
                }
                return false;
            });
            if (listeners.length === 0) {
                this.unbind(type, delegate.handler);
                delegate = this._delegates[type] = {};
            }
            return this;
        },

        &#x2F;**
         * Add class name
         *
         * @method addClass
         * @param {String} classname
         * @return {Object} TT object
         *&#x2F;
        addClass: domTester.classList ?
            function(className) {
                return this.each(function() {
                    this.classList.add(className);
                });
            } :
            function _addClassByClassName(className) {
                var stashName = this[0].className,
                    newName = _createName(stashName, className);

                return this.each(function(index) {
                    if (tt(this).hasClass(className)) {
                        return;
                    }
                    if (index &amp;&amp; stashName !== this.className) {
                        stashName = this.className;
                        newName = _createName(stashName, className);
                    }
                    this.className = newName;
                });

                function _createName(currentName, newName) {
                    var res = currentName.split(&quot; &quot;);

                    res[res.length] = newName;
                    return res.join(&quot; &quot;);
                }
            },

        &#x2F;**
         * Remove class name
         *
         * @method removeClass
         * @param {String} classname
         * @return {Object} TT object
         *&#x2F;
        removeClass: domTester.classList ?
            function _removeClassByClassList(className) {
                return this.each(function() {
                    this.classList.remove(className);
                });
            } :
            function _removeClassByClassName(className) {
                className = &quot; &quot; + className;
                return this.each(function() {
                    this.className = (&quot; &quot; + this.className).replace(className, &quot;&quot;).trim();
                });
            },

        &#x2F;**
         * Search class name
         *
         * @method hasClass
         * @param {String} classname
         * @return {Object} TT object
         *&#x2F;
        hasClass: domTester.classList ?
            function _hasClassByClassList(className) {
                return this.match(function() {
                    return this.classList.contains(className);
                });
            } :
            function _hasClassByClassName(className) {
                className = &quot; &quot; + className;
                return this.match(function() {
                    return (&quot; &quot; + this.className).indexOf(className) &gt; -1;
                });
            },

        &#x2F;**
         * Toggle class name
         *
         * @method toggleClass
         * @param {String} classname
         * @param {Bool} strict
         * @return {Object} TT object
         *&#x2F;
        toggleClass: function(className, strict) {
            var that = this;

            if (strict) {
                that.each(function() {
                    var target = tt(this);

                    if (target.hasClass(className)) {
                        target.removeClass(className);
                    } else {
                        target.addClass(className);
                    }
                });
            } else {
                if (tt(that[0]).hasClass(className)) {
                    that.removeClass(className);
                } else {
                    that.addClass(className);
                }
            }
            return this;
        },

        &#x2F;**
         * Find elements under registered elements
         *
         * @method find
         * @param {String} query
         * @return {Object} TT object
         *&#x2F;
        find: function(query) {
            var res = [];

            this.each(function() {
                res = res.concat(tt(query, this).toArray());
            });
            return tt(res);
        },

        &#x2F;**
         * Find NodeElement from registered elements
         *
         * @method contains
         * @param {String|Object} mix QueryString, NodeElement, NodeList
         * @return {Node} matches NodeElement
         *&#x2F;
        contains: function(mix) {
            var res = tt(),
                target = tt(mix);

            this.each(function() {
                var context = this,
                    cond = target.match(function() {
                        return context.contains(this);
                    });

                if (cond) {
                    res.push(this);
                }
            });
            return res;
        },

        &#x2F;**
         * Set attribute values
         * Get attributes list or attribute value
         *
         * @method attr
         * @param {String} mix QueryString, NodeElement, NodeList
         * @param {String|Object} mix QueryString, NodeElement, NodeList
         * @return {Object|String} Key-value object of attributes or attribute value
         *&#x2F;
        attr: function(mix, value) {
            var that = this;

            switch (arguments.length) {
            case 0:
                var attrs = this[0].attributes, attr;

                mix = {};
                for (var i = 0, iz = attrs.length; i &lt; iz; ++i) {
                    attr = attrs[i];
                    mix[attr.nodeName] = attr.nodeValue;
                }
                return mix;
            case 1:
                if (typeof mix === &quot;object&quot;) {
                    tt_each(mix, function(key) {
                        _setAttr(key, mix[key]);
                    });
                } else {
                    return this[0].getAttribute(mix);
                }
                break;
            case 2:
                _setAttr(mix, value);
                break;
            }
            return this;

            function _setAttr(key, value) {
                if (value === undefined || value === null) {
                    value = &quot;&quot;;
                }
                that.each(function() {
                    if (value === &quot;&quot;) {
                        this.removeAttribute(key);
                        return;
                    }
                    this.setAttribute(key, value);
                });
            }
        },

        &#x2F;**
         * Replace html in registered elements
         * or get text html in thier
         *
         * @method attr
         * @param {String} mix QueryString, NodeElement, NodeList
         * @param {String|Object} mix QueryString, NodeElement, NodeList
         * @return {Object|String} Key-value object of attributes or attribute value
         *&#x2F;
        html: function(mix) {
            if (mix === undefined || mix === null) {
                return this[0].innerHTML;
            }

            if (mix.nodeType) {
                this.clear().append(mix);
            } else {
                this.each(function() {
                    while (this.firstChild) {
                        this.removeChild(this.firstChild);
                    }
                    this.insertAdjacentHTML(&quot;afterbegin&quot;, mix);
                });
            }
            return this;
        },

        &#x2F;**
         * Append NodeElement or text html to registered elements
         *
         * @method append
         * @param {String|Node} mix NodeElement, Text html
         * @return {Object} TT object
         *&#x2F;
        append: function(mix) {
            var useClone = this.length &gt; 1;

            return this.each((typeof mix === &quot;string&quot;) ?
                function() { this.insertAdjacentHTML(&quot;beforeend&quot;, mix); } :
                function() {
					var that = this;

					if (mix.nodeType) {
						this.appendChild(useClone ? mix.cloneNode(true) : mix);
					} else if (mix instanceof TTCreater) {
						mix.each(function() {
							that.appendChild(this);
						});
					}
				});
        },

        &#x2F;**
         * Prepend NodeElement or text html to registered elements
         *
         * @method prepend
         * @param {String|Node} mix NodeElement, Text html
         * @return {Object} TT object
         *&#x2F;
        prepend: function(mix) {
            var useClone = this.length &gt; 1;

            return this.each((typeof mix === &quot;string&quot;) ?
                function() { this.insertAdjacentHTML(&quot;afterbegin&quot;, mix); } :
				function() {
					var that = this;

					if (mix.nodeType) {
						this.insertBefore(useClone ? mix.cloneNode(true) : mix, this.firstChild);
					} else if (mix instanceof TTCreater) {
						mix.each(function() {
							that.insertBefore(this, that.firstChild);
						});
					}
				});
        },

        &#x2F;**
         * Remove elements of registered from html
         *
         * @method remove
         * @return {Object} TT object
         *&#x2F;
        remove: function() {
            return this.each(function() {
                this.parentNode.removeChild(this);
            });
        },

        &#x2F;**
         * Remove child elements of registered elements
         *
         * @method clear
         * @return {Object} TT object
         *&#x2F;
        clear: function() {
            return this.each(function() {
                while (this.firstChild) {
                    this.removeChild(this.firstChild);
                }
            });
        },

        &#x2F;**
         * Get parent element from registered elements
         *
         * @method parent
         * @param {String|Object} mix Query string for search elements or TT object
         * @return {Object} TT object
         *&#x2F;
        parent: function(mix) {
            var res = tt();

            if (mix) {
                var target = tt(mix).toArray();

                this.each(function() {
                    if (target.indexOf(this.parentNode) &gt; -1) {
                        res.push(this.parentNode);
                    }
                });
            } else {
                this.each(function() {
                    res.push(this.parentNode);
                });
            }
            return res;
        },

        &#x2F;**
         * Get parent elements of the element back in DOM tree from registered elements
         *
         * @method parents
         * @param {String|Object} mix Query string for search elements or TT object
         * @return {Object} TT object
         *&#x2F;
        parents: function(mix) {
            var that = this,
                res;

            if (mix) {
                res = tt();
                tt(mix).each(function() {
                    var context = this,
                        match = that.match(function() {
                            var pos = context.compareDocumentPosition(this);

                            return (pos &amp; Node.DOCUMENT_POSITION_CONTAINED_BY);
                        });

                    if (match) {
                        res.push(this);
                    }
                });
            } else {
                res = [];
                this.match(function() {
                    var parent;

                    while ((parent = this.parentNode) !== null) {
                        if (res.indexOf(parent) === -1) {
                            res.push(parent);
                        } else {
                            break;
                        }
                    }
                    return false;
                });
                res = tt(res);
            }
            return res;
        },

        &#x2F;**
         * Get closest element from registered element with query string or target element
         *
         * @method closest
         * @param {String|Object} mix Query string for search elements or TT object
         * @return {Object} TT object
         *&#x2F;
        closest: function(mix) {
            var res = [],
                target;

            if (!mix) {
                return tt();
            }
            target = tt(mix).toArray();
            this.each(function() {
                var element = this;

                while (element) {
                    if (target.indexOf(element) &gt; -1) {
                        if (res.indexOf(element) === -1) {
                            res.push(element);
                        }
                        break;
                    }
                    element = element.parentNode;
                }
            });
            return tt(res);
        },

        &#x2F;**
         * Get child elements from registered elements
         *
         * @method children
         * @param {String|Object} [mix] QueryString, NodeElement, NodeList
         * @return {Object} tt object of matches child NodeElements
         *&#x2F;
        children: function(mix) {
            var res = tt(),
                target;

            if (mix) {
                target = tt(mix);
                this.each(function() {
                    var children = [].slice.call(this.children),
                        iz = children.length;

                    target.each(function() {
                        var child, i;

                        for (i = 0; i &lt; iz; ++i) {
                            child = children[i];
                            if (this === child) {
                                res.push(child);
                            }
                        }
                    });
                });
            } else {
                this.each(function() {
                    res = res.concat([].slice.call(this.children));
                });
            }
            return res;
        },

        &#x2F;**
         * Replace elements of registered elements
         *
         * @method replace
         * @param {String|Node} mix text html or NodeElement
         * @return {Object} TT object
         *&#x2F;
        replace: function(mix) {
            this.each((typeof mix === &quot;string&quot;) ?
                function() { this.insertAdjacentHTML(&quot;beforebegin&quot;, mix); } :
                function() { this.parentNode.insertBefore(mix, this); });
            return this.remove();
        },

        &#x2F;**
         * Set or get css styles
         *
         * @method css
         * @param {String|Object} [options] mix CSS property name, object of CSS style set
         * @param {String|Number} [options] value CSS style value
         * @return {String|Number|CSSStyleDeclaration}
         *&#x2F;
        css: function(mix, value) {
            var that = this;

            if (typeof mix === &quot;object&quot;) {
                tt_each(mix, function(key, val) {
                    if (val === &quot;&quot;) {
                        _removeProperty(key);
                        return;
                    }
                    _setStyle(tt_camelizer(key), val);
                });
            } else if (mix) {
                if (value) {
                    _setStyle(tt_camelizer(mix), value);
                } else if (value === &quot;&quot;) {
                    _removeProperty(mix);
                } else {
                    return global.getComputedStyle(this[0]).getPropertyValue(mix);
                }
            } else {
                return global.getComputedStyle(this[0]);
            }

            return this;

            function _removeProperty(prop) {
                that.each(function() {
                    this.style.removeProperty(prop);
                });
            }

            function _setStyle(prop, val) {
                that.each(function() {
                    this.style[prop] = val;
                });
            }
        },

        &#x2F;**
         * Set or get element&#x27;s dataset
         * If the array or object, data type passed to save the _data object instance
         *
         * @method data
         * @param {String|Object} [options] mix CSS property name, object of CSS style set
         * @param {String|Number} [options] value CSS style value
         * @return {String|Number|CSSStyleDeclaration}
         *&#x2F;
        data: (function() {
            var cond = domTester.dataset,
                _getDataAttr = cond ? _getDataByDataset : _getDataByAttributes,
                _setDataAttr = cond ? _setDataByDataset : _setDataByAttributes;

            return function (mix, value) {
                var that = this,
                    key;

                switch (arguments.length) {
                case 0:
                    return _getDataAttr.call(this);
                case 1:
                    if (typeof mix === &quot;object&quot;) {
                        tt_each(mix, function(key, val) {
                            _setDataAttr.call(that, key, val);
                        });
                        return this;
                    } else {
                        return _getDataAttr.call(this, mix);
                    }
                    break;
                case 2:
                    _setDataAttr.call(this, mix, value);
                    return this;
                }
            };

            function _setDataByDataset(key, val) {
                var type = tt_type(val),
                    func = null;

                if (val === &quot;&quot; ||
                    type === &quot;undefined&quot; ||
                    type === &quot;null&quot;) {
                        if (this._data[key]) {
                            delete this._data[key];
                            return;
                        } else {
                            func = function() { delete this.dataset[key]; };
                        }
                } else if (type === &quot;string&quot; || type === &quot;number&quot;) {
                    func = function() { this.dataset[key] = val; };
                } else {
                    this._data[key] = val;
                    return;
                }
                this.each(func);
            }

            function _getDataByDataset(key) {
                if (!this[0]) {
                    return null;
                }
                var node = this[0],
                    res = {};

                if (key) {
                    if (this._data[key]) {
                        return this._data[key] || null;
                    } else {
                        return node.dataset[key] || null;
                    }
                } else {
                    tt_each(node.dataset, function(key, val) {
                        res[key] = val;
                    });
                    tt_extend(res, this._data);
                }
                return res;
            }

            function _setDataByAttributes(key, val) {
                var type = tt_type(val);

                if (tt_type(val, [&quot;string&quot;, &quot;number&quot;, &quot;undefined&quot;, &quot;null&quot;])) {
                    if (val === &quot;&quot; &amp;&amp; this._data[key]) {
                        delete this._data[key];
                        return null;
                    }
                    this.attr(&quot;data-&quot; + key, val);
                } else {
                    this._data[key] = val;
                }
            }

            function _getDataByAttributes(key) {
                if (!this[0]) {
                    return null;
                }
                var res = {},
                    dataName = &quot;data-&quot;,
                    node = this[0],
                    attr, attrs = node.attributes,
                    i = 0, iz = attrs.length;

                if (!node) {
                    return null;
                } else if (this._data[key]) {
                    return this._data[key];
                } else if (key) {
                    dataName += key;
                    return this.attr(dataName);
                }
                for (; i &lt; iz; ++i) {
                    attr = attrs[i].name;
                    if (attr.indexOf(dataName) &gt; -1) {
                        key = attr.substr(5, attr.length);
                        res[key] = attrs[i].value;
                    }
                }
                tt_each(this._data, function(key, val) {
                    res[key] = val;
                });
                return res;
            }
        })(),

        &#x2F;**
         * Set, get &quot;value&quot; attributes value of registered elements
         *
         * @method val
         * @param {String|Number} [value]
         * @return {Object|String|Array} TT object, value or values list
         *&#x2F;
        val: function(value) {
            if (value !== undefined) {
                this.each(function() {
                    if (this.value !== undefined) {
                        this.value = value;
                    }
                });
                return this;
            } else {
                var res = [];

                this.each(function(index) {
                    if (this.value !== undefined) {
                        res[index] = this.value;
                    }
                });
                return this.length &gt; 1 ? res : res[0];
            }
        },

        &#x2F;**
         * Show elements, if it is hide curretly
         *
         * @method show
         * @param {String|Object} [options] value CSS value of display property
         * @return {Object} tt object
         *&#x2F;
        show: function(value) {
            var currentValue = this.css(&quot;display&quot;),
                lastValue = this._data.lastDisplay || null;

            if (currentValue !== &quot;none&quot;) {
                return;
            }
            return this.css(&quot;display&quot;, value || lastValue || &quot;block&quot;);
        },

        &#x2F;**
         * Hide elements, if it is show currently
         *
         * @method hide
         * @return {Object} tt object
         *&#x2F;
        hide: function() {
            var currentValue = this.css(&quot;display&quot;);

            if (currentValue !== &quot;none&quot;) {
                this._data.lastDisplay = currentValue;
            }
            return this.css(&quot;display&quot;, &quot;none&quot;);
        },

        &#x2F;**
         * Trigger events for registered elements
         *
         * @method trigger
         * @param {String} event event name
         * @param {String} type event type name
         * @param {Bool} [options] bubbles event bubbling flag
         * @param {Bool} [options] cancelable event cancelable flag
         * @return {Object} tt object
         *&#x2F;
        trigger: function() {
            var args = [].slice.call(arguments),
                type = args.shift(),
                ev = document.createEvent(&quot;Event&quot;);

            ev.initEvent(type, true, true);
            if (args.length &gt; 1) {
                ev._tt_data = args;
            }
            this.each(function() {
                this.dispatchEvent(ev);
            });
            return this;
        },

        &#x2F;**
         * Get offset position of registered elements
         * Ex.
         *  document.body
         *  +--------------------------
         *  |             |
         *  |            top
         *  |             v
         *  | -- left --&gt; +---------+
         *  |             | Element |
         *  |             +---------+
         *  |
         *
         * @method offset
         * @return {Object|Array} {left: Number, top: Number} or their array
         *&#x2F;
        offset: function() {
            var res = [];

            this.each(function(index) {
                var offset = this.getBoundingClientRect();

                res[index] = {
                    left: offset.left + global.pageXOffset,
                    top: offset.top + global.pageYOffset
                };
            });
            return this.length === 1 ? res[0] : res;
        },

        &#x2F;**
         * Get width from registered elements
         *
         * @method width
         * @param {Number} [index] number of registered elements
         * @return {Number} number of element width
         *&#x2F;
		width: function(index) {
			return this[index || 0].offsetWidth;
		},

        &#x2F;**
         * Get height from registered elements
         *
         * @method height
         * @param {Number} [index] number of registered elements
         * @return {Number} number of element height
         *&#x2F;
		height: function(index) {
			return this[index || 0].offsetHeight;
		}
    };

    &#x2F;&#x2F; globalize
    global[IDENT] = global[IDENT] || tt;

})((this.self || global), document);


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
